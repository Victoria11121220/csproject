use super::{
    node::{NodeError, NodeResult},
    types::{GraphPayload, GraphPayloadCollections, GraphPayloadMixed, GraphPayloadObjects},
    utils::collections_iter::PayloadCollectionsIterator,
};
use crate::readings::Readings;
use enum_dispatch::enum_dispatch;
use std::collections::HashSet;

#[enum_dispatch]
pub trait ConcreteNode {
    fn default_output_handle(&self) -> String {
        "source".to_string()
    }

    /// Set the actual input and output handles for the node.
    /// This function is called by the graph after the node is created and all edges are connected.
    /// It is used to both validate the handles and to set the actual handles that the node will use during computation.
    ///
    /// Most nodes will not need to know the actual handles as they can work with any input handles and get the output handle from the graph.
    /// However, some nodes might need to know the actual handles that are connected to properly format the output.
    /// For example, a node with a variable number of handles might need to know what is connected to properly format the output.
    ///
    /// # Validation
    /// Although this function does also perform validation of the handles, it should not perform an exhaustive validation.
    /// Only strictly necessary handles should be checked for existence and optional ones should be checked during computation.
    /// However, it is completely valid for a node to check if an optional handle is being used or not and change its behavior accordingly.
    /// Additionally, when checking output handles it is usually necessary only to check that no more handles than the expected ones are present.
    ///
    /// For example, if a node expects to have only one output, it should check that the size of the output handles is <= 1.
    /// It is important that the check is <= and not == as the node's output might not necessarily be connected to anything.
    fn set_actual_handles(&mut self, input_handles: HashSet<String>, output_handles: HashSet<String>) -> Result<(), NodeError>;

    /// Tell the graph whether the node generates a reading.
    ///
    /// If the node generates a reading, the graph will call the appropriate functions to convert the node's output to a reading.
    /// If this function returns `true`, the node must implement at least one of the reading conversion functions.
    /// The reading generation functions behave similarly to the computation functions, except that the graph does not attempt to normalize mixed payloads.
    /// If the node outputs mixed payloads, then the node must implement the mixed reading conversion function.
    fn generates_reading(&self) -> bool;

    /// Convert the node's output to a reading.
    ///
    /// The input is guaranteed to be the same object that was generated by the node's computation.
    fn payload_objects_to_reading(&self, _node_id: &str, _objects: &GraphPayloadObjects) -> Result<Readings, NodeError> {
        Err(NodeError::ComputationUnavailableError(
            "Objects to reading conversion is not implemented".to_string(),
        ))
    }

    /// Convert the node's output to a reading.
    ///
    /// The input is guaranteed to be the same collection that was generated by the node's computation.
    ///
    /// A default implementation is provided that maps over the collections and calls [`ConcreteNode::payload_objects_to_reading`] for each collection.
    /// Override this function if the node can convert the output to readings more efficiently given collections or if the output structure changes depending on the input.
    ///
    /// For example, a node might want to generate a single reading that internally groups the readings from the collections instead of generating a reading for each element in the collection.
    fn payload_collections_to_reading(&self, node_id: &str, collections: &GraphPayloadCollections) -> Result<Vec<Readings>, NodeError> {
        let mut readings = Vec::new();

        for input_payload in PayloadCollectionsIterator::new(collections) {
            readings.push(self.payload_objects_to_reading(node_id, &input_payload)?);
        }

        Ok(readings)
    }

    /// Convert the node's output to a reading.
    ///
    /// The input is guaranteed to be the same mixed payload that was generated by the node's computation.
    ///
    /// Realistically, if the node computation never generates mixed payloads, this function should never be called.
    /// Similarly, if the node computation always generates a certain type of payload, only the corresponding reading conversion function will be called.
    fn payload_mixed_to_reading(&self, _node_id: &str, _mixed: &GraphPayloadMixed) -> Result<Vec<Readings>, NodeError> {
        Err(NodeError::ComputationUnavailableError(
            "Mixed to reading conversion is not implemented".to_string(),
        ))
    }

    /// Compute the node's output given input objects.
    ///
    /// This function is the main entry point for the node's computation and most nodes will just need to implement this function only.
    /// The inputs are a map of input handle strings to input data which is guaranteed to be an object.
    /// The map might not contain an entry for every expected input handles as some inputs might be optional and no edge might be connected to them in the graph.
    /// If the node is not supposed to be able to handle object inputs, it should return a [`NodeError::ComputationUnavailableError`].
    ///
    /// If the graph is supposed to automatically take care of mapping over mixed and collection payloads using this function as the basis, the return payload should be a [`GraphPayload::Objects`].
    /// If this function can return other types of payloads, the node should implement the other payload processing functions as well.
    async fn compute_objects(&self, inputs: &GraphPayloadObjects) -> NodeResult;

    /// Compute the node's output given input collections.
    ///
    /// This is very similar to [`ConcreteNode::compute_objects`] but the inputs are guaranteed to be collections.
    /// The collections are also guaranteed to be the same length, but could be empty.
    /// Similarly to `compute_objects`, there are no guarantees on whether there will be a minimum number of collections as the node might have optional inputs.
    ///
    /// A default implementation is provided that maps over the vertical slices of the input collections and calls [`ConcreteNode::compute_objects`] for each slice.
    /// Override this function if the node can compute the output more efficiently given collections.
    /// The default implementation also assumes that:
    /// - The structure of the output of `compute_objects` does not change depending on the input.
    ///     Specifically, the output handles returned are assumed to be the same regardless of the input.
    /// - The output of `compute_objects` is an payload object like `NodeResultObjects`.
    /// 
    /// If these assumption do not hold, override this function as the default implementation will result in undefined behavior or errors at runtime.
    async fn compute_collections(&self, inputs: &GraphPayloadCollections) -> NodeResult {
        let mut result_collection = GraphPayloadCollections::new();

        // Iterate over vertical slices of the input collections
        for input_payload in PayloadCollectionsIterator::new(inputs) {
            // Attempt to obtain a NodeResultObjects from the node
            let node_result = self.compute_objects(&input_payload).await?;
            match node_result {
                GraphPayload::Objects(objects) => {
                    for (output_handle, object) in objects {
                        result_collection.entry(output_handle).or_default().push(object);
                    }
                }
                _ => {
                    // If this happens it means the node's implementation is incorrect and the default implementation of this function is not valid
                    return Err(NodeError::InvalidResultInDefaultCollections(format!(
                        "Expected NodeResultObjects, but got {:?}",
                        node_result
                    )));
                }
            }
        }

        Ok(GraphPayload::Collections(result_collection))
    }

    /// Compute the node's output given mixed input.
    ///
    /// Most of the times the graph should be able to normalize the mixed input into objects or collections and call the appropriate function.
    /// However, if this behavior is not desired, the node can implement this function to handle mixed input directly.
    ///
    /// No guarantees are made about the structure of the mixed input.
    /// It might contain objects, collections or a mix of both, or empty collections, or collections with different lengths.
    async fn compute_mixed(&self, _inputs: &GraphPayloadMixed) -> NodeResult {
        Err(NodeError::ComputationUnavailableError(
            "Mixed input processing is not implemented".to_string(),
        ))
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use crate::graph::types::NodeDataObject;
    use std::vec;

    struct MockConcreteNodeStatic {}
    impl ConcreteNode for MockConcreteNodeStatic {
        fn set_actual_handles(&mut self, _: HashSet<String>, _: HashSet<String>) -> Result<(), NodeError> {
            Ok(())
        }

        fn generates_reading(&self) -> bool {
            false
        }

        async fn compute_objects(&self, _: &GraphPayloadObjects) -> NodeResult {
            Err(NodeError::ComputationUnavailableError(
                "MockConcreteNodeStatic does not implement compute_objects".to_string(),
            ))
        }
    }

    #[tokio::test]
    async fn basic_static_test() {
        let node = MockConcreteNodeStatic {};
        assert!("source" == node.default_output_handle());
        assert!(matches!(node.payload_objects_to_reading("id", &GraphPayloadObjects::new()), Err(NodeError::ComputationUnavailableError(_))));
        assert_eq!(node.payload_collections_to_reading("id", &GraphPayloadCollections::new()).unwrap().len(), 0);
        let collections_payload: GraphPayloadCollections = vec![("a".to_string(), vec![NodeDataObject::from("a")])].into_iter().collect();
        assert!(matches!(node.payload_collections_to_reading("id", &collections_payload), Err(NodeError::ComputationUnavailableError(_))));
        assert!(matches!(node.compute_collections(&collections_payload).await, Err(NodeError::ComputationUnavailableError(_))));
        assert!(matches!(node.payload_mixed_to_reading("id", &GraphPayloadMixed::new()), Err(NodeError::ComputationUnavailableError(_))));
        assert!(matches!(node.compute_mixed(&GraphPayloadMixed::new()).await, Err(NodeError::ComputationUnavailableError(_))));
    }

    struct MockConcreteNodeIdentity {}
    impl ConcreteNode for MockConcreteNodeIdentity {
        fn set_actual_handles(&mut self, _: HashSet<String>, _: HashSet<String>) -> Result<(), NodeError> {
            Ok(())
        }

        fn generates_reading(&self) -> bool {
            true
        }

        async fn compute_objects(&self, inputs: &GraphPayloadObjects) -> NodeResult {
            Ok(GraphPayload::Objects(inputs.clone()))
        }

        fn payload_objects_to_reading(&self,_node_id: &str, _objects: &GraphPayloadObjects) -> Result<Readings,NodeError> {
            Ok(Readings::Empty(crate::readings::EmptyReading {}))
        }
    }

    #[tokio::test]
    async fn default_compute_collections() {
        let node = MockConcreteNodeIdentity {};
        let collections_payload: GraphPayloadCollections = vec![
            ("a".to_string(), vec![NodeDataObject::from(1.), NodeDataObject::from(11.)]),
            ("b".to_string(), vec![NodeDataObject::from(2.), NodeDataObject::from(22.)]),
        ].into_iter().collect();
        let result = node.compute_collections(&collections_payload).await;
        match result {
            Ok(GraphPayload::Collections(result_collection)) => {
                assert_eq!(result_collection.len(), 2);
                assert_eq!(result_collection.get("a").unwrap().len(), 2);
                assert_eq!(result_collection.get("b").unwrap().len(), 2);
                assert_eq!(result_collection.get("a").unwrap(), &vec![NodeDataObject::from(1.), NodeDataObject::from(11.)]);
                assert_eq!(result_collection.get("b").unwrap(), &vec![NodeDataObject::from(2.), NodeDataObject::from(22.)]);
            }
            _ => panic!("Expected GraphPayload::Collections, but got {:?}", result),
        }
    }

    #[test]
    fn default_collections_reading() {
        let node = MockConcreteNodeIdentity {};
        let collections_payload: GraphPayloadCollections = vec![
            ("a".to_string(), vec![NodeDataObject::from(1.), NodeDataObject::from(11.)]),
            ("b".to_string(), vec![NodeDataObject::from(2.), NodeDataObject::from(22.)]),
        ].into_iter().collect();
        let result = node.payload_collections_to_reading("id", &collections_payload);
        match result {
            Ok(readings) => {
                assert_eq!(readings.len(), 2);
                assert!(matches!(readings[0], Readings::Empty(_)));
                assert!(matches!(readings[1], Readings::Empty(_)));
            }
            _ => panic!("Expected Ok(readings), but got {:?}", result),
        }
    }

    struct MockConcreteNodeMixed {}
    impl ConcreteNode for MockConcreteNodeMixed {
        fn set_actual_handles(&mut self, _: HashSet<String>, _: HashSet<String>) -> Result<(), NodeError> {
            Ok(())
        }

        fn generates_reading(&self) -> bool {
            false
        }

        async fn compute_objects(&self, _: &GraphPayloadObjects) -> NodeResult {
            Ok(GraphPayload::Mixed(GraphPayloadMixed::new()))
        }
    }

    #[tokio::test]
    async fn default_collections_fail_on_non_object() {
        let node = MockConcreteNodeMixed {};
        let collections_payload: GraphPayloadCollections = vec![
            ("a".to_string(), vec![NodeDataObject::from(1.), NodeDataObject::from(11.)]),
            ("b".to_string(), vec![NodeDataObject::from(2.), NodeDataObject::from(22.)]),
        ].into_iter().collect();
        let result = node.compute_collections(&collections_payload).await;
        assert!(matches!(result, Err(NodeError::InvalidResultInDefaultCollections(_))));
    }
}